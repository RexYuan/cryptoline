\documentclass{article}

\usepackage{xspace}
\usepackage{amsbsy}
\usepackage{amsmath}

\newcommand{\derefop}{\mathit{\$}}
\newcommand{\deref}[1]{\mathit{\$#1}}
\newcommand{\wordsize}{W\xspace}
\newcommand{\cryptoline}{\textsc{Cryptoline}\xspace}
\newcommand{\prog}{\mathit{prog}\xspace}
\newcommand{\stmt}{\mathit{stmt}\xspace}
\newcommand{\proc}{\mathit{proc}\xspace}
\newcommand{\formals}{\mathit{formals}\xspace}
\newcommand{\true}{\mathit{true}\xspace}
\newcommand{\minusop}{-\xspace}
\newcommand{\eqop}{=\xspace}
\newcommand{\negop}{\sim\xspace}
\newcommand{\addop}{+\xspace}
\newcommand{\subop}{-\xspace}
\newcommand{\mulop}{*\xspace}
\newcommand{\powop}{**\xspace}
\newcommand{\landop}{\mathit{/\backslash}\xspace}
\newcommand{\lorop}{\mathit{\backslash/}\xspace}
\newcommand{\notop}{!\xspace}
\newcommand{\andop}{\mathit{\&}\xspace}
\newcommand{\orop}{\mathit{|}\xspace}
\newcommand{\xorop}{\mathit{\string^}\xspace}
\newcommand{\ultop}{\mathit{<}\xspace}
\newcommand{\uleop}{\mathit{<=}\xspace}
\newcommand{\ugtop}{\mathit{>}\xspace}
\newcommand{\ugeop}{\mathit{>=}\xspace}
\newcommand{\sltop}{\mathit{<s}\xspace}
\newcommand{\sleop}{\mathit{<=s}\xspace}
\newcommand{\sgtop}{\mathit{>s}\xspace}
\newcommand{\sgeop}{\mathit{>=s}\xspace}
\newcommand{\pre}{\mathit{pre}\xspace}
\newcommand{\post}{\mathit{post}\xspace}
\newcommand{\pred}{\mathit{pred}\xspace}
\newcommand{\epred}{\mathit{epred}\xspace}
\newcommand{\rpred}{\mathit{rpred}\xspace}
\newcommand{\predclause}{\mathit{pred\_clause}\xspace}
\newcommand{\epredclause}{\mathit{epred\_clause}\xspace}
\newcommand{\rpredclause}{\mathit{rpred\_clause}\xspace}
\newcommand{\iext}{\mathit{ext}\xspace}
\newcommand{\imod}{\mathit{mod}\xspace}
\newcommand{\iumod}{\mathit{umod}\xspace}
\newcommand{\ismod}{\mathit{smod}\xspace}
\newcommand{\isrem}{\mathit{srem}\xspace}
\newcommand{\ilimbs}{\mathit{limbs}\xspace}
\newcommand{\eexp}{\mathit{eexp}\xspace}
\newcommand{\rexp}{\mathit{rexp}\xspace}
\newcommand{\instr}{\mathit{instr}\xspace}
\newcommand{\imov}{\mathit{mov}\xspace}
\newcommand{\iadd}{\mathit{add}\xspace}
\newcommand{\iuadd}{\mathit{uadd}\xspace}
\newcommand{\isadd}{\mathit{sadd}\xspace}
\newcommand{\iadds}{\mathit{adds}\xspace}
\newcommand{\iuadds}{\mathit{uadds}\xspace}
\newcommand{\isadds}{\mathit{sadds}\xspace}
\newcommand{\iaddr}{\mathit{addr}\xspace}
\newcommand{\iuaddr}{\mathit{uaddr}\xspace}
\newcommand{\isaddr}{\mathit{saddr}\xspace}
\newcommand{\iadc}{\mathit{adc}\xspace}
\newcommand{\iuadc}{\mathit{uadc}\xspace}
\newcommand{\isadc}{\mathit{sadc}\xspace}
\newcommand{\iadcs}{\mathit{adcs}\xspace}
\newcommand{\iuadcs}{\mathit{uadcs}\xspace}
\newcommand{\isadcs}{\mathit{sadcs}\xspace}
\newcommand{\iadcr}{\mathit{adcr}\xspace}
\newcommand{\iuadcr}{\mathit{uadcr}\xspace}
\newcommand{\isadcr}{\mathit{sadcr}\xspace}
\newcommand{\isub}{\mathit{sub}\xspace}
\newcommand{\iusub}{\mathit{usub}\xspace}
\newcommand{\issub}{\mathit{ssub}\xspace}
\newcommand{\isubs}{\mathit{subs}\xspace}
\newcommand{\iusubs}{\mathit{usubs}\xspace}
\newcommand{\issubs}{\mathit{ssubs}\xspace}
\newcommand{\isubr}{\mathit{subr}\xspace}
\newcommand{\iusubr}{\mathit{usubr}\xspace}
\newcommand{\issubr}{\mathit{ssubr}\xspace}
\newcommand{\isbc}{\mathit{sbc}\xspace}
\newcommand{\iusbc}{\mathit{usbc}\xspace}
\newcommand{\issbc}{\mathit{ssbc}\xspace}
\newcommand{\isbcs}{\mathit{sbcs}\xspace}
\newcommand{\iusbcs}{\mathit{usbcs}\xspace}
\newcommand{\issbcs}{\mathit{ssbcs}\xspace}
\newcommand{\isbcr}{\mathit{sbcr}\xspace}
\newcommand{\iusbcr}{\mathit{usbcr}\xspace}
\newcommand{\issbcr}{\mathit{ssbcr}\xspace}
\newcommand{\imul}{\mathit{mul}\xspace}
\newcommand{\iumul}{\mathit{umul}\xspace}
\newcommand{\ismul}{\mathit{smul}\xspace}
\newcommand{\imuls}{\mathit{muls}\xspace}
\newcommand{\iumuls}{\mathit{umuls}\xspace}
\newcommand{\ismuls}{\mathit{smuls}\xspace}
\newcommand{\imulr}{\mathit{mulr}\xspace}
\newcommand{\iumulr}{\mathit{umulr}\xspace}
\newcommand{\ismulr}{\mathit{smulr}\xspace}
\newcommand{\imull}{\mathit{mull}\xspace}
\newcommand{\iumull}{\mathit{umull}\xspace}
\newcommand{\ismull}{\mathit{smull}\xspace}
\newcommand{\isplit}{\mathit{split}\xspace}
\newcommand{\ishl}{\mathit{shl}\xspace}
\newcommand{\icshl}{\mathit{cshl}\xspace}
\newcommand{\iset}{\mathit{set}\xspace}
\newcommand{\iclear}{\mathit{clear}\xspace}
\newcommand{\inondet}{\mathit{nondet}\xspace}
\newcommand{\icmov}{\mathit{cmov}\xspace}
\newcommand{\iand}{\mathit{and}\xspace}
\newcommand{\ior}{\mathit{or}\xspace}
\newcommand{\inot}{\mathit{not}\xspace}
\newcommand{\iassert}{\mathit{assert}\xspace}
\newcommand{\iassume}{\mathit{assume}\xspace}
\newcommand{\ighost}{\mathit{ghost}\xspace}
\newcommand{\icut}{\mathit{cut}\xspace}
\newcommand{\iecut}{\mathit{ecut}\xspace}
\newcommand{\ircut}{\mathit{rcut}\xspace}
\newcommand{\icall}{\mathit{call}\xspace}
\newcommand{\inop}{\mathit{nop}\xspace}
\newcommand{\iconst}{\mathit{const}\xspace}
\newcommand{\iprove}{\mathit{prove}\xspace}
\newcommand{\iwith}{\mathit{with}\xspace}
\newcommand{\provewith}{\mathit{prove\_with}\xspace}
\newcommand{\precondition}{\mathit{precondition}\xspace}
\newcommand{\all}{\mathit{all}\xspace}
\newcommand{\cuts}{\mathit{cuts}\xspace}
\newcommand{\assumes}{\mathit{assumes}\xspace}
\newcommand{\ghosts}{\mathit{ghosts}\xspace}
\newcommand{\varseq}{\mathit{varseq}\xspace}
\newcommand{\atomic}{\mathit{atomic}\xspace}
\newcommand{\atomicseq}{\mathit{atomicseq}\xspace}
\newcommand{\var}{\mathit{var}\xspace}
\newcommand{\simpleconst}{\mathit{simple\_const}\xspace}
\newcommand{\complexconst}{\mathit{complexy\_const}\xspace}
\newcommand{\const}{\mathit{const}\xspace}
\newcommand{\id}{\mathit{id}\xspace}
\newcommand{\letter}{\mathit{letter}\xspace}
\newcommand{\digit}{\mathit{digit}\xspace}
\newcommand{\underscore}{\mathit{underscore}\xspace}

\begin{document}

\title{\cryptoline}

\maketitle

\section{Introduction}

\cryptoline is a tool and a language for the verification of low-level
implementations of mathematical constructs.

\section{\cryptoline Language}

Assume a wordsize $\wordsize$.


\appendix
\section{Syntax of \cryptoline}
An \emph{identifier} is a regular string started by a letter or an underscore, followed by letters, digits, or underscores.
\[
\id ::= (\letter \mid \underscore) \{ \letter \mid \digit \mid \underscore \}
\]
A \emph{constant} is an integer, a named integer, or arithmetic expressions over constants.
\[
\begin{array}{rcl}
\const &  ::= & \simpleconst \\
       & \mid & \pmb{(}\ \complexconst\ \pmb{)} \\
\simpleconst &  ::= & \Sigma \\
             & \mid & \pmb{\derefop} \id \\
\complexconst &  ::= & \const \\
              & \mid & \pmb{\minusop}\ \complexconst \\
              & \mid & \complexconst\ \pmb{\addop}\ \complexconst \\
              & \mid & \complexconst\ \pmb{\subop}\ \complexconst \\
              & \mid & \complexconst\ \pmb{\mulop}\ \complexconst \\
              & \mid & \complexconst\ \pmb{\powop}\ \complexconst
\end{array}
\]
The value of a named integer $c$ is read by $\$c$.
\cryptoline supports the following arithmetic operators over constants: unary minus (\pmb{-}), addition (\pmb{+}), subtraction (\pmb{-}), multiplication (\pmb{*}), and exponent (\pmb{**}).
The value of a constant is always a bit vector of width $\wordsize$ unless its bit width is explicitly specified.
A \emph{variable} is an identity.
\[
\var ::= \id
\]
The value of a variable is always a bit vector of width $\wordsize$.
A sequence of variables is comma separated.
\[
\varseq ::= \var\ \{ \pmb{,}\ \var \}
\]
An \emph{atomic} is either a constant or a variable.
\[
\atomic ::= \const \mid \var
\]

\cryptoline supports the following \emph{instructions}.
\[
\begin{array}{rclcl}
\instr &  ::= & \pmb\imov\ \var\ \atomic %\\
       & \mid & \pmb\iadd\ \var\ \atomic\ \atomic \\
       & \mid & \pmb\iuadd\ \var\ \atomic\ \atomic %\\
       & \mid & \pmb\isadd\ \var\ \atomic\ \atomic \\
       & \mid & \pmb\iadds\ \var\ \var\ \atomic\ \atomic %\\
       & \mid & \pmb\iuadds\ \var\ \var\ \atomic\ \atomic \\
       & \mid & \pmb\isadds\ \var\ \var\ \atomic\ \atomic %\\
       & \mid & \pmb\iaddr\ \var\ \var\ \atomic\ \atomic \\
       & \mid & \pmb\iuaddr\ \var\ \var\ \atomic\ \atomic %\\
       & \mid & \pmb\isaddr\ \var\ \var\ \atomic\ \atomic \\
       & \mid & \pmb\iadc\ \var\ \atomic\ \atomic\ \var %\\
       & \mid & \pmb\iuadc\ \var\ \atomic\ \atomic\ \var \\
       & \mid & \pmb\isadc\ \var\ \atomic\ \atomic\ \var %\\
       & \mid & \pmb\iadcs\ \var\ \var\ \atomic\ \atomic\ \var \\
       & \mid & \pmb\iuadcs\ \var\ \var\ \atomic\ \atomic\ \var %\\
       & \mid & \pmb\isadcs\ \var\ \var\ \atomic\ \atomic\ \var \\
       & \mid & \pmb\iadcr\ \var\ \var\ \atomic\ \atomic\ \var %\\
       & \mid & \pmb\iuadcr\ \var\ \var\ \atomic\ \atomic\ \var \\
       & \mid & \pmb\isadcr\ \var\ \var\ \atomic\ \atomic\ \var %\\
       & \mid & \pmb\isub\ \var\ \atomic\ \atomic \\
       & \mid & \pmb\iusub\ \var\ \atomic\ \atomic %\\
       & \mid & \pmb\issub\ \var\ \atomic\ \atomic \\
       & \mid & \pmb\isubs\ \var\ \var\ \atomic\ \atomic %\\
       & \mid & \pmb\iusubs\ \var\ \var\ \atomic\ \atomic \\
       & \mid & \pmb\issubs\ \var\ \var\ \atomic\ \atomic %\\
       & \mid & \pmb\isubr\ \var\ \var\ \atomic\ \atomic \\
       & \mid & \pmb\iusubr\ \var\ \var\ \atomic\ \atomic %\\
       & \mid & \pmb\issubr\ \var\ \var\ \atomic\ \atomic \\
       & \mid & \pmb\isbc\ \var\ \atomic\ \atomic\ \var %\\
       & \mid & \pmb\iusbc\ \var\ \atomic\ \atomic\ \var \\
       & \mid & \pmb\issbc\ \var\ \atomic\ \atomic\ \var %\\
       & \mid & \pmb\isbcs\ \var\ \var\ \atomic\ \atomic\ \var \\
       & \mid & \pmb\iusbcs\ \var\ \var\ \atomic\ \atomic\ \var %\\
       & \mid & \pmb\issbcs\ \var\ \var\ \atomic\ \atomic\ \var \\
       & \mid & \pmb\isbcr\ \var\ \var\ \atomic\ \atomic\ \var %\\
       & \mid & \pmb\iusbcr\ \var\ \var\ \atomic\ \atomic\ \var \\
       & \mid & \pmb\issbcr\ \var\ \var\ \atomic\ \atomic\ \var %\\
       & \mid & \pmb\imul\ \var\ \atomic\ \atomic \\
       & \mid & \pmb\iumul\ \var\ \atomic\ \atomic %\\
       & \mid & \pmb\ismul\ \var\ \atomic\ \atomic \\
       & \mid & \pmb\imuls\ \var\ \var\ \atomic\ \atomic %\\
       & \mid & \pmb\iumuls\ \var\ \var\ \atomic\ \atomic \\
       & \mid & \pmb\ismuls\ \var\ \var\ \atomic\ \atomic %\\
       & \mid & \pmb\imulr\ \var\ \var\ \atomic\ \atomic \\
       & \mid & \pmb\iumulr\ \var\ \var\ \atomic\ \atomic %\\
       & \mid & \pmb\ismulr\ \var\ \var\ \atomic\ \atomic \\
       & \mid & \pmb\imull\ \var\ \var\ \atomic\ \atomic %\\
       & \mid & \pmb\iumull\ \var\ \var\ \atomic\ \atomic \\
       & \mid & \pmb\ismull\ \var\ \var\ \atomic\ \atomic %\\
       & \mid & \pmb\iset\ \var \\
       & \mid & \pmb\iclear\ \var %\\
       & \mid & \pmb\inondet\ \var \\
       & \mid & \pmb\icmov\ \var\ \var\ \atomic\ \atomic %\\
       & \mid & \pmb\ishl\ \var\ \atomic\ \const \\
       & \mid & \pmb\icshl\ \var\ \var\ \atomic\ \atomic\ \const %\\
       & \mid & \pmb\isplit\ \var\ \var\ \atomic\ \const \\
       & \mid & \pmb\iand\ \var\ \atomic\ \atomic %\\
       & \mid & \pmb\ior\ \var\ \atomic\ \atomic \\
       & \mid & \pmb\inot\ \var\ \atomic %\\
       & \mid & \pmb\iassert\ \pred \\
       & \mid & \pmb\iassume\ \pred %\\
       & \mid & \pmb\icut\ \predclause \\
       & \mid & \pmb\iecut\ \epredclause %\\
       & \mid & \pmb\ircut\ \rpredclause \\
       & \mid & \pmb\ighost\ \varseq\ \pmb{:}\ \pred %\\
       & \mid & \pmb\icall\ \id\ \pmb{(}\ [ \atomic\ \{\pmb{,}\ \atomic \} ]\ \pmb{)} \\
       & \mid & \pmb\inop
\end{array}
\]

An \emph{algebraic expression} is evaluated over $\Sigma$.
\[
\begin{array}{rclcl}
\eexp &  ::= & \simpleconst %\\
      & \mid & \var \\
      & \mid & \pmb{-}\ \eexp %\\
      & \mid & \eexp\ \pmb{+}\ \eexp \\
      & \mid & \eexp\ \pmb{-}\ \eexp %\\
      & \mid & \eexp\ \pmb{*}\ \eexp \\
      & \mid & \eexp\ \pmb{**}\ \eexp %\\
      & \mid & \pmb\ilimbs\ \const\ \pmb{[}\ \eexp\ \{\pmb{,}\ \eexp\}\ \pmb{]} \\
      & \mid & \pmb{(}\ \eexp\ \pmb{)}
\end{array}
\]
A \emph{range expression} is evaluated over bit vectors.
\[
\begin{array}{rclcl}
\rexp &  ::= & \pmb\iconst\ \const\ \const %\\
      & \mid & \pmb{-}\ \rexp \\
      & \mid & \rexp\ \pmb\addop\ \rexp %\\
      & \mid & \rexp\ \pmb\subop\ \rexp \\
      & \mid & \rexp\ \pmb\mulop\ \rexp %\\
      & \mid & \pmb\negop\ \rexp \\
      & \mid & \pmb\notop\ \rexp %\\
      & \mid & \rexp\ \pmb\andop\ \rexp \\
      & \mid & \rexp\ \pmb\orop\ \rexp %\\
      & \mid & \rexp\ \pmb\xorop\ \rexp \\
      & \mid & \pmb\iumod\ \rexp\ \rexp %\\
      & \mid & \pmb\isrem\ \rexp\ \rexp \\
      & \mid & \pmb\ismod\ \rexp\ \rexp %\\
      & \mid & \pmb\iext\ \rexp\ \const \\
      & \mid & \pmb\ilimbs\ \const\ \pmb{[}\ \rexp\ \{\pmb{,}\ \rexp\}\ \pmb{]} %\\
      & \mid & \pmb{(}\ \rexp\ \pmb{)}
\end{array}
\]

A \emph{predicate} is represented by an algebraic predicate and a range predicate.
\[
\begin{array}{rclcl}
\pred &  ::= & \true %\\
      & \mid & \epred\ \pmb{\&\&}\ \rpred
\end{array}
\]
An \emph{algebraic predicate} specifies the equalities (possibly modular a number) between variables.
\[
\begin{array}{rclcl}
\epred &  ::= & \true %\\
       & \mid & \eexp\ \pmb\eqop\ \eexp \\
       & \mid & \eexp\ \pmb\eqop\ \eexp\ \pmb(\ \imod\ \eexp\ \pmb) %\\
       & \mid & \epred\ \pmb{\landop} \epred\\
       & \mid & \pmb{\landop}\ \pmb{[}\ \epred\ \{\pmb{,}\ \epred\}\ \pmb{]} %\\
       & \mid & \pmb{(}\ \epred\ \pmb{)} \\
\end{array}
\]
A \emph{range predicate} specifies the ranges of variables.
\[
\begin{array}{rclcl}
\rpred &  ::= & \true %\\
       & \mid & \rexp\ \pmb\eqop\ \rexp \\
       & \mid & \rexp\ \pmb\eqop\ \rexp\ \pmb(\ \imod\ \rexp\ \pmb) %\\
       & \mid & \rexp\ \pmb\ultop\ \rexp \\
       & \mid & \rexp\ \pmb\uleop\ \rexp %\\
       & \mid & \rexp\ \pmb\ugtop\ \rexp \\
       & \mid & \rexp\ \pmb\ugeop\ \rexp %\\
       & \mid & \rexp\ \pmb\sltop\ \rexp \\
       & \mid & \rexp\ \pmb\sleop\ \rexp %\\
       & \mid & \rexp\ \pmb\sgtop\ \rexp \\
       & \mid & \rexp\ \pmb\sgeop\ \rexp %\\
       & \mid & \negop \rpred \\
       & \mid & \rpred\ \pmb{\landop} \rpred %\\
       & \mid & \rpred\ \pmb{\lorop} \rpred\\
       & \mid & \pmb{\landop}\ \pmb{[}\ \rpred\ \{\pmb{,}\ \rpred\}\ \pmb{]} %\\
       & \mid & \pmb{\lorop}\ \pmb{[}\ \rpred\ \{\pmb{,}\ \rpred\}\ \pmb{]} \\
       & \mid & \pmb{(}\ \rpred\ \pmb{)}
\end{array}
\]

Sometimes a predicate has to be proved with facts that have been cut off.
\cryptoline offers the specification of hints required to prove a predicate.
\[
\begin{array}{rclcl}
\predclause &  ::= & \true %\\
            & \mid & \epredclause\ \pmb{\&\&}\ \rpredclause \\
\epredclause &  ::= & \epred %\\
             & \mid & \epred\ \pmb\iprove\ \pmb\iwith\ \provewith\ \{\pmb{,}\ \provewith\} \\
\rpredclause &  ::= & \rpred %\\
             & \mid & \rpred\ \pmb\iprove\ \pmb\iwith\ \provewith\ \{\pmb{,}\ \provewith\} \\
\provewith &  ::= & \pmb\precondition %\\
           & \mid & \pmb\all\ \pmb\cuts \\
           & \mid & \pmb\all\ \pmb\assumes %\\
           & \mid & \pmb\all\ \pmb\ghosts \\
\end{array}
\]

A \emph{procedure} is a parameterized program together with its specification (precondition and postcondition).
\[
\proc ::= \pmb\proc\ \id\ \pmb{(}\ [\formals]\ \pmb{)} = [\pmb\{\ \pre\ \pmb\}]\ \prog\ [\pmb\{\ \post\ \pmb\}]
\]
The \emph{formal parameters} of a procedure are separated (by a semicolon) into \emph{inout} and \emph{out} variables.
\[
\formals ::= \varseq\ \pmb{;}\ \varseq
\]
Variables before the semicolon are inout variables while variables after the semicolon are out variables.
The difference between inout and out variables is that when calling a procedure, actual parameters of the inout formal variables must be defined but this is not required for the actual parameters of the out formal variables.
However, this does not mean that an out variable can be read before initialized.
Every variable must be initialized before reading its value.
A \emph{precondition} is a predicate.
\[
\pre ::= \pred
\]
A \emph{postcondition} is a predicate clause.
\[
\post ::= \predclause
\]

A \emph{statement} is a declaration of a procedure or a named integer.
\[
\begin{array}{rclcl}
\stmt &  ::= & \proc %\\
      & \mid & \pmb\iconst\ \id\ \pmb\eqop\ \const
\end{array}
\]

A \emph{program} is a sequence of statements.
The entry point of the program is the \emph{main} procedure.
Other procedures called in main are inlined.
\[
\prog ::= \stmt\ \{ \stmt \}
\]


\end{document}
